import java.io.*;
import java.util.zip.*;

public class WorkWithZip {

    public static void addFilesToZip(File nameZip, File[] nameFiles) {
        // Добавление файлов в существующий архив происходит посредством создания временного архива,
        // необходимого для того, чтобы удержать уже имеющиеся в сущестующем архиве файлы,
        // (если просто начать запись в архив, то его содержимое обновится, а старые файлы будут утеряны).
        // Файлы одинаковым названием перезаписываются новыми.

        try{
            // Создаем временный архив-файл с именем переданного в функцию архива с суффиксом .tmp
            // (такой суффикс по умолчанию при значении второго аргумента = null)
            // и связываем переменную tempZip с созданным архивом-файлом.
            // В результе будет создан пустой файл в каталоге по умолчанию для временных файлов:
            File tempZip = File.createTempFile(nameZip.getName(), null);
            tempZip.delete(); // удаляем созданный физический объект в ОС

            // Переименовываем существющий архив с имеющимися в нем данными именем временного архива
            // и проверяем успешность выполнения команды (.renameTo() возвращает true/false).
            // Если операция не выполнена, то "выбрасываем" исключение, прерываем вызов функции
            if(!nameZip.renameTo(tempZip)) {
                throw new Exception("Не удалось создать временный архив " + nameZip.getName());
            }

            // Связываем архив с переданным исходным именем с потоком на запись в него:
            ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(nameZip));

            // Связываем имя временного архива, в котором хранятся имеющиеся файлы исходного архива,
            // с потоком на чтение из него, (чтобы прочитать и записать файлы в итоговый архив):
            ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(tempZip));

            // Начинаем формировать итоговый архив.
            // Сначала запишем в него переданные в функцию файлы:
            for(int i = 0; i < nameFiles.length; i++) { // проходимся в цикле по всем переданным в функцию файлам
                // Чтобы записать файл в архив, создаем объект ZipEntry для каждого файла:
                ZipEntry zipEntry = new ZipEntry(nameFiles[i].getName());

                // Добавляем сущность (заголовок) файла nameFiles[i] в архив:
                zipOutputStream.putNextEntry(zipEntry);

                // Теперь необходимо записать все содержимое файла nameFiles[i].
                // Связываем файл nameFiles[i] с потоком на чтение из него:
                FileInputStream fileInputStream = new FileInputStream(nameFiles[i]);

                int length; // следующий байт в потоке при чтении файла
                byte[] buffer = new byte[1024]; // массив байтов для считывания содержимого файла

                // Метод .read() возвращает число int, которое представляет следующий байт в потоке.
                // При достижении конца потока возвращает -1.
                // Цикл выполняется, пока не достигнут конец файла:
                while((length = fileInputStream.read(buffer)) > 0) {
                    // Метод .write() записывает символы длиной buffer, начиная с позиции 0 и заканчивая length
                    zipOutputStream.write(buffer,0, length); // записываем содержимое текущего файла nameFiles[i]
                }

                fileInputStream.close(); // закрываем поток на чтение содержимого файла nameFiles[i]
                zipOutputStream.closeEntry(); // закрываем поток на чтение текущей сущности (заголовка) файла nameFiles[i]
            }

            // Продолжаем формировать итоговый архив.
            // Теперь запишем в него файлы, которые хранились там ранее. Файлы с одинаковым именем перезапишем новыми.
            // Для этого считаем их из временного архива, куда были перенесены все исходно хранящиеся файлы.
            // В цикле проходимся по каждой сущности, которые записаны во временный архив (ранее открывали поток на чтение 32 строка):
            for(ZipEntry zipEntry = zipInputStream.getNextEntry(); zipEntry != null; zipEntry = zipInputStream.getNextEntry()) {

                // Перед добавлением старого файла проверим, есть ли он среди списка добавленных файлов.
                // Если есть, то старый файл не добавляем
                boolean isExist = false; // равен true, если среди исходных файлов имеется файл с одинаковым названием среди добавляемых
                String zipFileName = zipEntry.getName(); // получаем имя файла текущей сущности
                // Проходимся по добавляемым файлам, переданным функции
                for(File file : nameFiles) {
                    if(file.getName().equals(zipFileName)) { // если имя какого-то добавляемого файла совпадает с именем текущей сущности исходного архива
                        isExist = true; // флажок меняется на true
                        break; // выходим из цикла
                    }
                }

                // Перед добавлением текущей сущности проверяем, был ли файл с таким же именем среди добавляемых файлов
                if(isExist) {
                    continue; // если был, то данную сущность с ее содержимым не записываем и переходим к следующей
                }

                // Продолжаем запись в итоговый массив.
                // Аналогично добавляем сущность (заголовок):
                zipOutputStream.putNextEntry(zipEntry);

                // И добавляем содежимое файла:
                int length; // следующий байт в потоке при чтении файла
                byte[] buffer = new byte[1024]; // массив байтов для считывания содержимого файла
                while((length = zipInputStream.read(buffer)) > 0) { // Цикл выполняется, пока не достигнут конец файла:
                    zipOutputStream.write(buffer,0, length); // записываем содержимое текущего файла
                }

                zipOutputStream.closeEntry(); // закрываем поток на чтение текущей сущности (заголовка) файла

            }

            // После того, как записали все файлы в итоговый архив, можно закрыть потк на запись в него:
            zipOutputStream.close();

            // Временный архив больше не нужен, удаляем его:
            tempZip.delete();
        } catch(Exception e) { // Перехватываем исключения
            System.out.println("Не удалось добавить файлы в архив: " + e);
        }
    }

    public static void main(String[] args) throws IOException {

        // Связываем переменную с существующим архивом, куда нужно добавить файлы:
        File zip = new File("abcde.zip");

        // Связывваем переменную с дирректорией, в которой лежат файлы для добавления:
        File addToZip = new File(".\\addToZip");

        // Добавляем в массив файлов все файлы из директории:
        File[] files = addToZip.listFiles();

        // Вызываем функцию:
        addFilesToZip(zip, files);

    }
}